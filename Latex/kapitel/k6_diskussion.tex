\chapter{Fazit und Ausblick}

Das entworfene Metamodell für Microservices kann nun genutzt werden, um basierend auf einem modellgetriebenen Entwicklungsansatz Software zu entwickeln. Dadurch wurde die grundlegende Zielsetzung erfolgreich erfüllt. Weiterhin sind diese Anwendungen auch mit relativ geringem Mehraufwand in eine Cloud-Umgebung auslieferbar. Dementsprechend konnte gezeigt werden, dass die einer Microservice-Architektur zugrunde liegende Infrastruktur, in diesem Fall eine Kubernetes-Architektur in der Google Cloud, berücksichtigt werden kann. Es wurde außerdem gezeigt, dass Microservices auch in einem Deployment-fähigen Zustand modellgetrieben entwickelt werden können.

Trotzdem muss berücksichtigt werden, dass einige vereinfachende Annahmen und Architekturentscheidungen zugunsten dieser Ergebnisse getroffen wurden. Einige davon lassen sich dabei durchaus mit den selbst definierten Entscheidungs- und Bewertungskriterien als sinnvoll und nützlich bewerten. So ist die pragmatische Lösung, ein Microservice-Anwendungsimage auf maximal einen Pod laufen zu lassen, eine Vereinfachung, die für das Lösen von Anwendungsfällen hinreichend ist. Auch die sehr einfache Modellierung des Messaging-Systems Kafka hat sich als ausreichend für den erfolgreichen Betrieb einer Microservice-Architektur erwiesen. Kritischer sind Modellierungsentscheidungen wie das Fehlen einer abstrakten Messaging-Konfigurationsklasse oder der Google Cloud-spezifischen Maschinentyp-Modellierung innerhalb der Kubernetes-Konfigurationsklasse einzuordnen.

Der tatsächliche Mehrwert dieser konzeptionell breiten Modellierung kann ebenfalls kritisch hinterfragt werden. Es ist notwendig, jeden einzelnen Service in einer der Generierung folgenden, feineren Implementierung zu vervollständigen. Dann müssen diese über die erzeugten Skripte manuell ausgerollt werden. Es stellt sich die Frage, inwiefern sich der Aufwand durch den generierten Code reduziert bzw. sogar erhöht. Wie würde sich dies bei einer hochskalierenden Anzahl an Diensten entwickeln? Durch die Erfassung von Software-Qualitätsmetriken ließe sich dies beispielsweise messen. Auch die Möglichkeiten von erhöhter Automatisierung, wie beispielsweise das Modellieren von Deployment-Pipelines und Infrastructure as Code, könnten in diesem Zusammenhang vielversprechende Erweiterungen des Metamodells sein.

Weiterhin wurde versucht, die Eigenschaften von Microservice-Architekturen in das Metamodell einfließen zu lassen. So konnte erfolgreich das Konzept des Domain-Driven Designs in ein Metamodell integriert werden. Es zeigt sich, dass die Abstraktion des DDD gut durch eine konkrete Syntax ausgedrückt werden kann. Diese eignet sich insbesondere sehr gut um Problemdomänen zu analysieren. Die direkte Verbindung zu den technischen Microservice-Konzepten vereinfacht daraufhin die ersten Schritte des Grobentwurfs. Insbesondere die Veranschaulichung der verteilten Systemarchitektur und der genutzten Kommunikationskanäle konnte effektiv umgesetzt werden. Weiterhin zeigt sich der Vorteil des Model-Driven Designs, da die Symmetrien zwischen Codebasis und Modell beachtlich sind. Aber auch hier können wieder verschiedene vereinfachende Abstraktionsschritte thematisiert werden. So wurden viele tiefergehende Konzepte, insbesondere aus dem Bereich des Betriebs wie Monitoring oder Metriken, aber auch Aspekte der Datenbankimplementierung, nicht in das Modell integriert. Dies zeigte sich zwar als nicht unmittelbar notwendig, um lauffähige Anwendungen zu entwickeln, die Problemstellungen lösen. Jedoch könnte man auch argumentieren, dass dies Bereiche sind, die zumindest in einem Modell, das Anspruch auf Vollständigkeit erheben würde, notwendig wären.

Bei der Modellierung des Strategic Designs aus dem DDD kann man auch den dadurch entstandenen Mehrwert kritisch diskutieren. So ist im Rahmen der Problemerfassung und -modellierung ein Verständnis und die Visualisierung der unterschiedlichen Kontexte und ihrer Beziehung zueinander sicherlich hilfreich. Aber der effektive Mehrwert bei einer Codegenerierung konnte während der Konzeption nicht festgestellt werden. Dies lag insbesondere an der Entscheidung, die Attributierung der Modellelemente nicht intensiv zu berücksichtigen. Die Fragestellung, ob eine Modellierung des Strategic Designs im Kontext der Codegenerierung gewinnbringend eingesetzt werden kann, bleibt offen.

Auch die Modellierung von Entities, Value Objects und insbesondere Aggregates ist zu hinterfragen. Die modellierten Assoziationen, die diese Klassen besitzen, wurden im Rahmen der Generierung nicht effektiv aufgegriffen. Die Entscheidung die innere Struktur dieser Klassen händisch zu implementieren zeigte sich in der Umsetzung als eingängiger. Weiterhin existieren andere Metamodelle, die sich auf die Modellierung von Datenstrukturen spezialisieren. Diese aufzugreifen, wäre möglicherweise eine bessere Lösung.

Die Entscheidung, das Metamodell in Schichten zu strukturieren, bot zwar den Vorteil einer klaren Grundstruktur. Retrospektiv zeigten sich jedoch auch Schwächen. Anfangs wurden einige konzeptionelle Gemeinsamkeiten bei der initialen Abstraktion auf Basis eines Modells erkannt. Dabei entwickelte sich die anfangs als technische Schicht abstrahierte Ebene jedoch überraschend anders als erwartet. Es zeigte sich, dass eine zwischenzeitliche explizite Modellierung der fachlichen Interpretation des MDD und der zusätzlichen Interpretation auf Implementierungsebene nicht notwendig war. Dies führte dazu, dass eine Schicht entstand, deren konzeptioneller Kern eher die Kommunikation umfasste. Es stellt sich die Frage, welche Schichteneinteilung geeigneter gewesen wäre. Insbesondere könnte eine ergänzende vertikale Schichtbildung, zusätzlich zur bisherigen horizontalen Einteilung in Fachlichkeit, technische Umsetzung und Infrastruktur, sehr aufschlussreich sein. Eine solche Abstraktion, die den einzelnen Bounded Context, dessen Service und dessen Infrastruktur als eine Komponente begreift, sowie eine weitere Abstraktion, die Gruppen solcher Komponenten beschreibt, könnte interessante Ergebnisse liefern.

Durch die konzipierte Codegenerierung wurde demonstriert, dass Microservice-Anwendungen modellgetrieben erstellt werden können, wobei viele Vorteile der modellgetriebenen Softwareentwicklung genutzt werden. Der modellzentrierte Ansatz ermöglicht insbesondere bei umfassenden und grundlegenden Änderungen, die eine große Anzahl an Services betreffen, eine effektive Umsetzung. Dies gilt vor allem, wenn die Entwicklung von Anfang an modellgetrieben erfolgt, da auf diese Weise manuell hinzugefügter Code geschützt werden kann. Allerdings bedarf die konkrete Umsetzung der Generierung einer genaueren Betrachtung. Es bestehen signifikante Abhängigkeiten zwischen der Generierung und dem Metamodell. So hat sich gezeigt, dass die Art und Weise, wie das Spring Framework Objekte instanziiert, in Kombination mit dem konzipierten Metamodell zu äußerst komplexen und kognitiv anspruchsvollen Templates führen kann.

Die Handhabung von Kafka Producern und Consumern mit Spring wirft die Frage auf, ob eine abstrakte bidirektionale Referenz zwischen Modellelementen und Interfaces auf der Generierungsebene passend ist. Dies liegt an der Dependency Injection, die dazu führt, dass Modellelemente eine klar gerichtete Assoziation zu Produzenten und eine Assoziation zu ihnen von Konsumenten haben. Hier wäre es interessant herauszufinden, wie eine Generierung auf Basis dieses Metamodells mit einer anderen Implementierungstechnologie umgesetzt werden würde. Auch könnte man retrospektiv fordern, dass die Modellierung darauf verzichtet, technologieunabhängige Dienste zu generieren. Dafür würde man die technologiespezifischen Besonderheiten, zum Beispiel die eines Spring Frameworks, bei der Abstraktion berücksichtigen.

Im speziellen Kontext von Migrationen wurde einerseits gezeigt, wie Refaktorisierungen mit diesem Metamodell prinzipiell umgesetzt werden können. Hierbei liegen die Stärken insbesondere in der Veränderung der Grundstruktur von Anwendungen. So lassen sich beispielsweise Änderungen, die sich in Konfigurationsdateien oder Java-Klassen durch das Hinzufügen bzw. Entfernen bestehenden Codes realisieren lassen, gut in einem modellgetriebenen Ansatz umsetzen. Schwieriger gestaltet sich dies bei Änderungen, die bereits feinimplementierten Quellcode betreffen. Hierfür können zwar existierende Technologien wie OpenRewrite integriert werden, jedoch ist eine Nutzung dieser auch unabhängig von einem modellgetriebenen Einsatz denkbar.

Es kann auch notwendig sein, eine Migration einer noch höheren Größenordnung durchzuführen, wie etwa wenn eine Anwendung auf eine völlig neue Technologie umgestellt werden soll. Dabei bringt der modellgetriebene Ansatz, insbesondere zur initialen Codegenerierung, einige interessante Aspekte mit sich, da vor allem das fachliche Modell erhalten bleibt. Auch hier wären Erkenntnisse durch ergänzende Konzepte, die dieses Modell mit einer anderen Zieltechnologie umsetzen, nützlich.

Zusammenfassend lässt sich festhalten, dass das in dieser Arbeit konzipierte Modell für Anwendungen in einem überschaubaren Rahmen solide Ergebnisse liefert, aber die inhaltliche Tiefe von Microservice-Architekturen, der Betrieb dieser in verschiedenen Cloud-Umgebungen und die Fragestellung der effektiven Nutzung für Migrationen nur angeschnitten werden konnten. Zukünftige wissenschaftliche Arbeiten könnten an diesen Ansätzen anknüpfen und auf den in dieser Arbeit gewonnenen Erkenntnissen und Ideen für eine potenziell effektivere Modellierung und Generierung aufbauen.